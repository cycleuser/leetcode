
class Solution:
    # 定义一个解码方法的数量的类
    def numDecodings(self, s: str) -> int:
        """
        计算给定字符串s中的数字解码方式数量。
        
        参数:
            s (str): 给定的包含星号和数字字符的字符串
        
        返回:
            int: 解码方式的数量，结果对10^9 + 7取模
        """

        # 如果第一个字符是'0'，直接返回0，因为无法解码
        if s[0] == "0":
            return 0

        # 初始化动态规划数组的前两个值
        dp1 = dp2 = 1

        # 处理第一个字符为'*'的情况
        if s[0] == "*":
            dp2 = 9

        # 遍历字符串从第二个字符开始
        for i in range(1, len(s)):
            # 当前两个字符组成的数
            couple, newDp1 = s[i - 1:i + 1], dp2
            
            # 如果当前字符是'0'
            if s[i] == "0":
                # 如果前一个字符也是'0'或大于等于'3'，则无法解码返回0
                if s[i - 1] == "0" or s[i - 1] >= "3": 
                    return 0
                # 更新dp2为当前的dp1值乘以2（因为两个字符可以看作一个整体）
                dp2 = 2 * dp1 if s[i - 1] == "*" else dp1

            # 当前字符是'*'
            elif s[i] == "*":
                # '*'代表0到9，所以乘以9
                dp2 *= 9
                # 如果前一个字符为'2', 则当前'*'可以组合成20-26，共6种可能，加上dp1的值
                if s[i - 1] == "2":
                    dp2 += 6 * dp1
                # 前一个字符为'1', '*0-*9'共有9种解码方式，加到dp2中
                elif s[i - 1] == "1":
                    dp2 += 9 * dp1
                # 前一个字符为'*', 当前 '*'可以与'1'和'2'组合成10-19或20-26，共15种可能
                elif s[i - 1] == "*":
                    dp2 += 15 * dp1

            # 当前两个字符组成的数在10到26之间
            elif "10" <= couple <= "26": 
                # 加上dp1的值，因为这两个数字组合可以单独解码
                dp2 += dp1
            
            # 前一个字符为'*'且当前字符小于等于'6'
            elif s[i - 1] == "*" and s[i] <= "6":
                # '*'可以与前一位置的字符组成10-19或20-26，共12种可能
                dp2 += 2 * dp1

            else:
                # 其他情况，直接加上dp1的值
                dp2 += dp1
            
            # 更新dp1为上一步的结果
            dp1 = newDp1
        
        # 返回结果对10^9 + 7取模
        return dp2 % (10 ** 9 + 7)
